/*
 * STM32F446RE_GPIO_DRIVER.h
 *
 * Created on: Oct 14, 2025
 * Author: notty
 */

#ifndef INC_STM32F446RE_GPIO_DRIVER_H_
#define INC_STM32F446RE_GPIO_DRIVER_H_

#include "STM32F446RE.h"
#include <stdint.h>


//====================== Configuration and Handle Structures ======================

/**
 * @brief  GPIO pin configuration structure
 * This structure will be filled by the user to configure a GPIO pin.
 */
typedef struct
{
    uint8_t GPIO_PinNumber;      /*!< Specifies the GPIO pin to be configured. This parameter can be a value of @ref GPIO_PIN_NUMBERS */
    uint8_t GPIO_PiMode;         /*!< Specifies the operating mode for the selected pin. This parameter can be a value of @ref GPIO_MODES */
    uint8_t GPIO_PinSpeed;       /*!< Specifies the speed for the selected pin. This parameter can be a value of @ref GPIO_PIN_OUPUT_POSSIBLE_SPEED */
    uint8_t GPIO_PinPupdControl; /*!< Specifies the Pull-up or Pull-down activation for the selected pin. This parameter can be a value of @ref GPIO_PIN_PULL_UP_AND_PULL_DOWN_CONFIGURATION */
    uint8_t GPIO_PinOpType;      /*!< Specifies the output type for the selected pin. This parameter can be a value of @ref GPIO_OUTPUT_TYPE */
    uint8_t GPIO_PinAltFunMode;  /*!< Specifies the alternate function value */

} GPIO_Pin_Config_t;

/**
 * @brief  GPIO handle structure
 * This structure holds the base address of the GPIO port and the pin configuration.
 */
typedef struct
{
    GPIO_Reg_Def *pGPIOX;               /*< This holds the base address of the GPIO port to which the pin belongs */
    GPIO_Pin_Config_t GPIO_Pin_Config;  /*< This holds GPIO pin configuration settings */

} GPIO_Handle_t;


//================================= Driver Macros =================================

/*
 * @ref GPIO_MODES
 * GPIO pin possible modes
 */
#define GPIO_MODE_IN        0
#define GPIO_MODE_OUT       1
#define GPIO_MODE_ALTFN     2
#define GPIO_MODE_ANALOG    3
#define GPIO_MODE_IT_FT     4  // Interrupt Falling edge trigger
#define GPIO_MODE_IT_RT     5  // Interrupt Rising edge trigger
#define GPIO_MODE_IT_RFT    6  // Interrupt Rising-Falling edge trigger

/*
 * @ref GPIO_OUTPUT_TYPE
 * GPIO pin possible output types
 */
#define GPIO_OP_TYPE_PP     0  // Push-Pull
#define GPIO_OP_TYPE_OD     1  // Open-Drain

/*
 * @ref GPIO_PIN_OUPUT_POSSIBLE_SPEED
 * GPIO pin possible output speeds
 */
#define GPIO_SPEED_LOW      0
#define GPIO_SPEED_MEDIUM   1
#define GPIO_SPEED_FAST     2
#define GPIO_SPEED_HIGH     3

/*
 * @ref GPIO_PIN_PULL_UP_AND_PULL_DOWN_CONFIGURATION
 * GPIO pin pull-up and pull-down configurations
 */
#define GPIO_NO_PUPD        0
#define GPIO_PIN_PU         1
#define GPIO_PIN_PD         2

/*
 * @ref GPIO_PIN_NUMBERS
 * GPIO pin numbers
 */
#define GPIO_PIN_NO_0       0
#define GPIO_PIN_NO_1       1
#define GPIO_PIN_NO_2       2
#define GPIO_PIN_NO_3       3
#define GPIO_PIN_NO_4       4
#define GPIO_PIN_NO_5       5
#define GPIO_PIN_NO_6       6
#define GPIO_PIN_NO_7       7
#define GPIO_PIN_NO_8       8
#define GPIO_PIN_NO_9       9
#define GPIO_PIN_NO_10      10
#define GPIO_PIN_NO_11      11
#define GPIO_PIN_NO_12      12
#define GPIO_PIN_NO_13      13
#define GPIO_PIN_NO_14      14
#define GPIO_PIN_NO_15      15


//=========================== API Function Prototypes ===========================

/* Peripheral Clock Setup */
void GPIO_PeriClockControl(GPIO_Reg_Def *pGPIOX, uint8_t EnOrDi);

/* Init and De-init */
void GPIO_Init(GPIO_Handle_t *pGPIOHandle);
void GPIO_DeInit(GPIO_Reg_Def *pGPIOX);

/* Data Read and Write */
uint8_t GPIO_ReadFromInputPin(GPIO_Reg_Def *pGPIOX, uint8_t PinNumber);
uint16_t GPIO_ReadFromInputPort(GPIO_Reg_Def *pGPIOX);
void GPIO_WriteToOutputPin(GPIO_Reg_Def *pGPIOX, uint8_t PinNumber, uint8_t Value);
void GPIO_WriteToOutputPort(GPIO_Reg_Def *pGPIOX, uint16_t Value);
void GPIO_ToggleOutputPin(GPIO_Reg_Def *pGPIOX, uint8_t PinNumber);

/* IRQ Configuration and ISR Handling */
void GPIO_IRQConfig(uint8_t IRQNumber, uint8_t IRQPriority, uint8_t EnOrDi);
void GPIO_IRQHandling(uint8_t PinNumber);


//=========================== API Function Definitions ===========================
// NOTE: Function definitions are typically placed in a corresponding .c file.

/**
 * @brief Enables or disables peripheral clock for a given GPIO port.
 */
void GPIO_PeriClockControl(GPIO_Reg_Def *pGPIOX, uint8_t EnOrDi)
{
    if (EnOrDi == ENABLE)
    {
        if (pGPIOX == GPIOA) { GPIOA_PCLK_EN(); }
        else if (pGPIOX == GPIOB) { GPIOB_PCLK_EN(); }
        else if (pGPIOX == GPIOC) { GPIOC_PCLK_EN(); }
        else if (pGPIOX == GPIOD) { GPIOD_PCLK_EN(); }
        else if (pGPIOX == GPIOE) { GPIOE_PCLK_EN(); }
        else if (pGPIOX == GPIOF) { GPIOF_PCLK_EN(); }
        else if (pGPIOX == GPIOG) { GPIOG_PCLK_EN(); }
        else if (pGPIOX == GPIOH) { GPIOH_PCLK_EN(); }
    }
    else
    {
        // NOTE: Clock disable macros were not defined in the previous file.
        // Assuming they would be named GPIOx_PCLK_DI().
        if (pGPIOX == GPIOA) { /* GPIOA_PCLK_DI(); */ }
        else if (pGPIOX == GPIOB) { /* GPIOB_PCLK_DI(); */ }
        else if (pGPIOX == GPIOC) { /* GPIOC_PCLK_DI(); */ }
        else if (pGPIOX == GPIOD) { /* GPIOD_PCLK_DI(); */ }
        else if (pGPIOX == GPIOE) { /* GPIOE_PCLK_DI(); */ }
        else if (pGPIOX == GPIOF) { /* GPIOF_PCLK_DI(); */ }
        else if (pGPIOX == GPIOG) { /* GPIOG_PCLK_DI(); */ }
        else if (pGPIOX == GPIOH) { /* GPIOH_PCLK_DI(); */ }
    }
}

/**
 * @brief Initializes a GPIO pin according to the settings in the handle.
 */
void GPIO_Init(GPIO_Handle_t *pGPIOHandle)
{
    uint32_t temp = 0;

    // 1. Configure the mode of the pin
    if (pGPIOHandle->GPIO_Pin_Config.GPIO_PiMode <= GPIO_MODE_ANALOG)
    {
        temp = (pGPIOHandle->GPIO_Pin_Config.GPIO_PiMode << (2 * pGPIOHandle->GPIO_Pin_Config.GPIO_PinNumber));
        pGPIOHandle->pGPIOX->MODER &= ~(0x3 << (2 * pGPIOHandle->GPIO_Pin_Config.GPIO_PinNumber)); // Clear bits
        pGPIOHandle->pGPIOX->MODER |= temp; // Set bits
    }
    else
    {
        // TODO: Interrupt mode configuration
    }
    temp = 0;

    // 2. Configure the speed
    temp = (pGPIOHandle->GPIO_Pin_Config.GPIO_PinSpeed << (2 * pGPIOHandle->GPIO_Pin_Config.GPIO_PinNumber));
    pGPIOHandle->pGPIOX->OSPEEDER &= ~(0x3 << (2 * pGPIOHandle->GPIO_Pin_Config.GPIO_PinNumber)); // Clear
    pGPIOHandle->pGPIOX->OSPEEDER |= temp; // Set
    temp = 0;

    // 3. Configure the pupd settings
    temp = (pGPIOHandle->GPIO_Pin_Config.GPIO_PinPupdControl << (2 * pGPIOHandle->GPIO_Pin_Config.GPIO_PinNumber));
    pGPIOHandle->pGPIOX->PUPDR &= ~(0x3 << (2 * pGPIOHandle->GPIO_Pin_Config.GPIO_PinNumber)); // Clear
    pGPIOHandle->pGPIOX->PUPDR |= temp; // Set
    temp = 0;

    // 4. Configure the output type
    temp = (pGPIOHandle->GPIO_Pin_Config.GPIO_PinOpType << pGPIOHandle->GPIO_Pin_Config.GPIO_PinNumber);
    pGPIOHandle->pGPIOX->OTYPER &= ~(0x1 << pGPIOHandle->GPIO_Pin_Config.GPIO_PinNumber); // Clear
    pGPIOHandle->pGPIOX->OTYPER |= temp; // Set
    temp = 0;

    // 5. Configure the alternate functionality
    if (pGPIOHandle->GPIO_Pin_Config.GPIO_PiMode == GPIO_MODE_ALTFN)
    {
        uint32_t temp1, temp2;
        temp1 = pGPIOHandle->GPIO_Pin_Config.GPIO_PinNumber / 8; // determines AFR[0] or AFR[1]
        temp2 = pGPIOHandle->GPIO_Pin_Config.GPIO_PinNumber % 8; // determines the bit position within the register
        pGPIOHandle->pGPIOX->AFR[temp1] &= ~(0xF << (4 * temp2)); // Clear
        pGPIOHandle->pGPIOX->AFR[temp1] |= (pGPIOHandle->GPIO_Pin_Config.GPIO_PinAltFunMode << (4 * temp2)); // Set
    }
}

/**
 * @brief Resets all registers for a given GPIO port to their default values.
 */
void GPIO_DeInit(GPIO_Reg_Def *pGPIOX)
{
    if (pGPIOX == GPIOA) { GPIOA_REG_RESET(); }
    else if (pGPIOX == GPIOB) { GPIOB_REG_RESET(); }
    else if (pGPIOX == GPIOC) { GPIOC_REG_RESET(); }
    else if (pGPIOX == GPIOD) { GPIOD_REG_RESET(); }
    else if (pGPIOX == GPIOE) { GPIOE_REG_RESET(); }
    else if (pGPIOX == GPIOF) { GPIOF_REG_RESET(); }
    else if (pGPIOX == GPIOG) { GPIOG_REG_RESET(); }
    else if (pGPIOX == GPIOH) { GPIOH_REG_RESET(); }
}

/**
 * @brief Reads the value from a specific input pin.
 */
uint8_t GPIO_ReadFromInputPin(GPIO_Reg_Def *pGPIOX, uint8_t PinNumber)
{
    uint8_t value;
    value = (uint8_t)((pGPIOX->IDR >> PinNumber) & 0x00000001);
    return value;
}

/**
 * @brief Reads the value from the entire input port.
 */
uint16_t GPIO_ReadFromInputPort(GPIO_Reg_Def *pGPIOX)
{
    uint16_t value;
    value = (uint16_t)pGPIOX->IDR;
    return value;
}

/**
 * @brief Writes a value (SET or RESET) to a specific output pin.
 */
void GPIO_WriteToOutputPin(GPIO_Reg_Def *pGPIOX, uint8_t PinNumber, uint8_t Value)
{
    if (Value == GPIO_PIN_SET)
    {
        // Set the bit
        pGPIOX->ODR |= (1 << PinNumber);
    }
    else
    {
        // Clear the bit
        pGPIOX->ODR &= ~(1 << PinNumber);
    }
}

/**
 * @brief Writes a 16-bit value to the entire output port.
 */
void GPIO_WriteToOutputPort(GPIO_Reg_Def *pGPIOX, uint16_t Value)
{
    pGPIOX->ODR = Value;
}

/**
 * @brief Toggles the state of a specific output pin.
 */
void GPIO_ToggleOutputPin(GPIO_Reg_Def *pGPIOX, uint8_t PinNumber)
{
    pGPIOX->ODR ^= (1 << PinNumber);
}

/**
 * @brief Configures IRQ settings (not implemented).
 */
void GPIO_IRQConfig(uint8_t IRQNumber, uint8_t IRQPriority, uint8_t EnOrDi)
{
    // To be implemented
}

/**
 * @brief Handles IRQ (not implemented).
 */
void GPIO_IRQHandling(uint8_t PinNumber)
{
    // To be implemented
}


#endif /* INC_STM32F446RE_GPIO_DRIVER_H_ */
